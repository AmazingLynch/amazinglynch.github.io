{"componentChunkName":"component---src-templates-blog-post-js","path":"/bundler/","result":{"data":{"site":{"siteMetadata":{"title":"Colgin's Blog"}},"markdownRemark":{"id":"1b59455d-ccf2-55e6-91de-49a481803951","excerpt":"尽管现在 rollup/webpack 功能已经很强大了，但是对于一个库的开发者来说，如何配置出一个最佳实践并不是一个简单的事情，因此社区中有很多机遇rollup/webpack…","html":"<p>尽管现在 rollup/webpack 功能已经很强大了，但是对于一个库的开发者来说，如何配置出一个最佳实践并不是一个简单的事情，因此社区中有很多机遇rollup/webpack封装的打包工具，每个工具都各有特点，让开发者能够不用关心打包的问题，一个命令就输出符合最佳实践的产物。本文将介绍多种不同的打包工具，并进行横向比较，探究他们的技术选型以及种种权衡。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>tsup</th>\n<th>tsdx</th>\n<th>unbuild</th>\n<th>microbundle</th>\n<th>ncc</th>\n<th>bunchee</th>\n<th>pkgroll</th>\n<th>bundt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>star</td>\n<td>3000</td>\n<td>10100</td>\n<td>790</td>\n<td>7200</td>\n<td>7000</td>\n<td>154</td>\n<td>118</td>\n<td>157</td>\n</tr>\n<tr>\n<td>author</td>\n<td>egoist</td>\n<td>jaredpalmer</td>\n<td>unjs/nuxt</td>\n<td>developit</td>\n<td>vercel</td>\n<td>huozi</td>\n<td>privatenumber</td>\n<td>lukeed</td>\n</tr>\n<tr>\n<td>underhood</td>\n<td>rollup + esbuild</td>\n<td>rollup + babel</td>\n<td>rollup + esbuild</td>\n<td>rollup + babel</td>\n<td>webpack</td>\n<td>rollup + swc</td>\n<td>rollup + esbuild</td>\n<td>string replacement</td>\n</tr>\n<tr>\n<td>ts support</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n<td>no</td>\n</tr>\n<tr>\n<td>compiler</td>\n<td>esbuild</td>\n<td>babel</td>\n<td>esbuild</td>\n<td>babel</td>\n<td>无</td>\n<td>swc</td>\n<td>esbuild</td>\n<td>无</td>\n</tr>\n<tr>\n<td>output format</td>\n<td>esm + cjs + iife</td>\n<td>cjs, esm, umd</td>\n<td>esm + cjs</td>\n<td>esm + cjs + umd</td>\n<td>cjs or mjs(只输出node环境代码)</td>\n<td>cjs, esm， umd</td>\n<td>esm, cjs</td>\n<td>esm,cjs,umd</td>\n</tr>\n<tr>\n<td>global env</td>\n<td>支持所有，需要在配置中加上需要替换的值</td>\n<td>默认只支持 <code class=\"language-text\">_DEV_</code>和<code class=\"language-text\">process.env.NODE_ENV</code>，其他需要自定义rollup实现</td>\n<td>本身不做替换 ，如果要替换通过rollup配置替换</td>\n<td>支持，cli上 —define可以配置</td>\n<td></td>\n<td>无</td>\n<td>支持替换</td>\n<td>不支持，保留</td>\n</tr>\n<tr>\n<td>es version</td>\n<td>es6+ ， es5 by swc</td>\n<td>babel自己配置</td>\n<td>es2020，不可配置</td>\n<td>es6 + mordern mode</td>\n<td>无</td>\n<td>es5</td>\n<td>es6+</td>\n<td>无</td>\n</tr>\n<tr>\n<td>declareation file</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n<td>？</td>\n<td>yes</td>\n<td>yes</td>\n<td>无</td>\n</tr>\n<tr>\n<td>config</td>\n<td>单独配置文件，package.json, cli</td>\n<td>单独配置文件，cli</td>\n<td>单独的配置文件，package.json</td>\n<td>cli, package.json</td>\n<td>cli, package.json</td>\n<td>cli</td>\n<td>cli, package.json</td>\n<td>package.json, cli</td>\n</tr>\n<tr>\n<td>others</td>\n<td>支持多入口</td>\n<td>有初始化程序，有多种模板，天然支持react + ts</td>\n<td>开箱即用的vue支持，支持bundless output，支持Passive watcher</td>\n<td>支持css module，worker输出</td>\n<td>inline all dependencies</td>\n<td></td>\n<td></td>\n<td>external all dependencies</td>\n</tr>\n</tbody>\n</table>\n<h2>可配置</h2>\n<p>上面工具基本都是底层工具的上层封装，为了不将api 设计地过于臃肿，有的就直接利用 package.json 里的字段，有的通过命令行指定，有的支持单独的配置文件。</p>\n<h2>compiler</h2>\n<h3>esbuild</h3>\n<p>esbuild 的特点是 快，以及开箱即用的 ts 支持，但是esbuild 最低只支持 编译到 es6，而且不支持 polyfill，如果你的库使用到了一些非常新的api，你可能需要自己从 <code class=\"language-text\">core-js</code> 中导入 polyfill。具体参考<a href=\"https://esbuild.github.io/api/#target\">esbuild#target</a>。</p>\n<blockquote>\n<p>Note that this is only concerned with syntax features, not APIs. It does <em>not</em> automatically add <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Polyfill\">polyfills</a> for new APIs that are not used by these environments. You will have to explicitly import polyfills for the APIs you need (e.g. by importing <a href=\"https://www.npmjs.com/package/core-js\"><code class=\"language-text\">core-js</code></a>). Automatic polyfill injection is outside of esbuild’s scope.</p>\n</blockquote>\n<p>除此之外，esbuild 对于 js 的编译文件也有一些<a href=\"https://esbuild.github.io/content-types/#javascript-caveats\">限制</a></p>\n<ul>\n<li>不支持编译到es5</li>\n<li><code class=\"language-text\">#name</code> private member 有性能问题</li>\n<li>不可直接使用 eval 函数</li>\n</ul>\n<p>esbuild 对于 ts 的编译也有一些<a href=\"https://esbuild.github.io/content-types/#typescript-caveats\">限制</a></p>\n<ul>\n<li>无法生成 <code class=\"language-text\">d.ts</code></li>\n</ul>\n<h3>swc</h3>\n<p>swc 和 esbuild 一样可以做代码的编译器，开箱即用的 ts 支持，与esbuild比较起来，swc 可以将代码编译到 es5。比如 tsup 当 <code class=\"language-text\">--target es5</code> 时，就会先用 esbuild 编译到 es6， 然后再用 swc 将 es6 代码编译到 es5.</p>\n<h3>babel</h3>\n<p>最常见的，不过多介绍</p>\n<h3>buble</h3>\n<p>buble 早期被定义为babel 的替代品，用来解决babel的一些问题，不过随着babel的发展，加上buble长时间不更新，现在基本很少用buble作为转译器了。microbundle 早期就是用 buble 进行转译，在<a href=\"https://github.com/developit/microbundle/pull/263\">pr</a> 中替换成了babel</p>\n<h2>输出文件</h2>\n<p>使用esbuild 或者 babel 处理 js其实都无法生成 <code class=\"language-text\">d.ts</code>, 然而作为一个使用 <code class=\"language-text\">ts</code> 书写的库，提供可靠的 类型文件是非常有必要的，因此大部分打包器都支持 生成一份最后的 类型文件</p>\n<h3>bundless output</h3>\n<p>大部分打包器 都会将所有的文件打包在一个文件，然后以一种特定的格式输出。但是像 unbuild 这类工具，提供了一种新的输出，就是只做 file-to-file 的编译工作，输出和输入的代码结构保持一致。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>defineBuildConfig<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'unbuild'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token function\">defineBuildConfig</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n\tentries<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n\t\t<span class=\"token comment\">// default</span>\n\t\t<span class=\"token string\">'src/index'</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token comment\">// mkdist builder transpiles file-to-file keeping original sources structure</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\tbuilder<span class=\"token operator\">:</span> <span class=\"token string\">'mkdist'</span><span class=\"token punctuation\">,</span>\n\t\t\tinput<span class=\"token operator\">:</span> <span class=\"token string\">'./src/'</span><span class=\"token punctuation\">,</span>\n\t\t\toutDir<span class=\"token operator\">:</span> <span class=\"token string\">'esm'</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n\tdeclaration<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>全局变量</h3>\n<p>有时候会在代码里写</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">funciton <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xx'</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>通过这种方式，可以在 开发环境做一些友好的提示。但是很多打包器都会在打包的时候把这些变量进行替换，比如 tsup 可以通过 <code class=\"language-text\">tsup src/index.ts --env.NODE_ENV production</code> 来替换全局变量，这样打包的结果就变成了</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xx'</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>（注：这种代码经过代码压缩之后 整个 if 代码块都会被移除）</p>\n<p>所以 当用户使用你的库的时候，实际上是看不到 任何提示的，因为你打包的时候已经把这些提示移除了。这显然是不太友好的，tsdx 针对 这种情况 提出了一个最佳实践。见<a href=\"https://tsdx.io/optimization#development-only-expressions-treeshaking\">Development-only Expressions + Treeshaking</a></p>\n<p>比如针对源文件</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// ./src/index.ts</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Helpful dev-only error message'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>会生成 3 个 commonjs文件 (dev, prod, entry)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Entry File</span>\n<span class=\"token comment\">// ./dist/index.js'use strict';</span>\n<span class=\"token comment\">// This determines which build to use based on the `NODE_ENV` of your end user.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">===</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./mylib.cjs.production.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\tmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./mylib.cjs.development.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// CommonJS Development Build</span>\n<span class=\"token comment\">// ./dist/mylib.cjs.development.js'</span>\nuse strict'<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">{</span>\n\t\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Helpful dev-only error message'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nexports<span class=\"token punctuation\">.</span>sum <span class=\"token operator\">=</span> sum<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//# sourceMappingURL=mylib.cjs.development.js.map</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// CommonJS Production Build</span>\n<span class=\"token comment\">// ./dist/mylib.cjs.production.js</span>\n<span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\nexports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">s<span class=\"token punctuation\">,</span> t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> s <span class=\"token operator\">+</span> t<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//# sourceMappingURL=test-react-tsdx.cjs.production.js.map</span></code></pre></div>\n<p>可以看到通过这种方式 可以区分 production 和 development 两种不同环境了，而且也不会影响产物的size。</p>\n<p>而 ESM，这些环境变量会保留不会做替换，留给终端用户去做替换（webpack，rollup 都会自动处理 NODE_ENV 的替换)</p>\n<p><a href=\"https://github.com/facebook/react/blob/main/packages/react/npm/index.js\">React</a> 和 <a href=\"https://github.com/vuejs/core/blob/main/packages/vue/index.js\">Vue</a> 其实都采用了类似的策略</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">===</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./cjs/react.production.min.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\tmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./cjs/react.development.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>external</h3>\n<p>外部依赖要不要打包进最终的产物，这是一个看似简单，其实工程上需要考虑多一些，因为无论既可以打包进去，也可以不打包进去，二者各有优缺点，本文不做深入讲解。各个打包工具的大概有以下几种选择</p>\n<ul>\n<li>依赖打包进去，比如 ncc</li>\n<li>peerDependencies, dependencies 全部 external， devDependencies 全部打包: 比如 pkgroll, tsup</li>\n<li>依赖全部 external，比如 bundt</li>\n<li>自行配置</li>\n</ul>\n<p>其实 大部分 都是选择第二种方案，这也是大家默认的最佳实践。具体原因参考 <a href=\"https://github.com/developit/microbundle/wiki/How-Microbundle-decides-which-dependencies-to-bundle\">How Microbundle decides which dependencies to bunlde</a></p>\n<h2>ESM 和 commonjs 的兼容性</h2>\n<p>node 中有一些 api 在 esm中并不支持，比如 <code class=\"language-text\">__dirname</code>, <code class=\"language-text\">__filename</code>, <code class=\"language-text\">require</code>, <code class=\"language-text\">require.resolve</code>。同理 esm 有一些变量在 node 中也不支持，比如 <code class=\"language-text\">import.meta.url</code> 。这些转化 底层的 esbuild 其实都没有处理，见 <a href=\"https://esbuild.github.io/getting-started/#bundling-for-node\">bundling-for-node</a>。</p>\n<p>本文中一些打包器有时候会宣称自己是 <strong>Node.js ESM</strong> &#x3C;=> <strong>CJS friendly</strong>, 他们往往会做一些处理。比如</p>\n<p>commonjs 中的 require 会被 编译为 <code class=\"language-text\">createRequire(import.meta.url)</code></p>\n<p>如果代码中使用到了 <code class=\"language-text\">import.meta.url</code></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">consoleImportUrl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">import</span><span class=\"token punctuation\">.</span>meta<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>microbundle esm 中的 <code class=\"language-text\">import.meta.url</code> 会被编译为</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">exports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">consoleImportUrl</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'undefined'</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">typeof</span> document\n\t<span class=\"token operator\">?</span> <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"url\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token constant\">URL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"file:\"</span> <span class=\"token operator\">+</span> __filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>href\n\t<span class=\"token operator\">:</span> document<span class=\"token punctuation\">.</span>currentScript <span class=\"token operator\">&amp;&amp;</span> document<span class=\"token punctuation\">.</span>currentScript<span class=\"token punctuation\">.</span>src <span class=\"token operator\">||</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">URL</span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo.js\"</span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span>baseURI<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>href<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>而tsup 默认只则只做了简单的shim</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">var</span> import_meta <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">consoleImportUrl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>import_meta<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以通过 <code class=\"language-text\">--shims</code> 可以加上类似于 microbundle 那种完整的兼容代码。见<a href=\"https://github.com/egoist/tsup/releases\">tsup release6.0</a></p>\n<p>commonjs 中的 <code class=\"language-text\">__dirname</code> 会被编译为</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> dirname <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'path'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> fileURLToPath <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'url'</span>\n\n<span class=\"token keyword\">const</span> _dirname <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> __dirname <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span>\n  <span class=\"token operator\">?</span> __dirname\n  <span class=\"token operator\">:</span> <span class=\"token function\">dirname</span><span class=\"token punctuation\">(</span><span class=\"token function\">fileURLToPath</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">import</span><span class=\"token punctuation\">.</span>meta<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li><a href=\"https://github.com/privatenumber/pkgroll#esm--cjs-interoperability\">pkgroll: esm &#x3C;=> cjs interoperability</a></li>\n<li><a href=\"https://antfu.me/posts/publish-esm-and-cjs#context-misalignment\">Context misalignment</a></li>\n</ul>\n<h2>非 ts/js 文件支持</h2>\n<p>除了 ts/js 文件之外，实际的项目还可能有比如 ，json，jsx，css 等各种格式的文件，不同打包器对这类文件支持程度也不一样。</p>\n<p>tsup 由于使用了 esbuild，esbuild 中有很多内置的<a href=\"https://esbuild.github.io/content-types/\">loader</a>，</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Loader</span> <span class=\"token operator\">=</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'js'</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'jsx'</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'ts'</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'tsx'</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'css'</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'json'</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'text'</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'base64'</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'file'</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'dataurl'</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'binary'</span>\n  <span class=\"token operator\">|</span> <span class=\"token string\">'default'</span>\n</code></pre></div>\n<p>可以通过 <code class=\"language-text\">--loader \".jpg=base64\"</code> 使用 <code class=\"language-text\">base64</code> loader 去加载 <code class=\"language-text\">.jpg</code> 文件</p>\n<h2>watch模式</h2>\n<p>通过上面的表格可以知道，他们都是基于 rollup / webpack 的二次封装，rollup 和 webpack 都有 watch 模式，因此这些打包器的监听模式也是基于 rollup/webpack 的监听模式实现的，会开启一个进程，监控所有文件，当文件发生变化的时候，重新进行打包。</p>\n<p>unbuild 提供了一种新思路，叫做 <code class=\"language-text\">passive watcher</code>, 也叫 stub 模式，通过 <code class=\"language-text\">unbuild --stub</code> 可以一次生成目标文件，之后无论你原代码如何修改，都不会重新编译构建。这取决于 <a href=\"https://github.com/unjs/jiti\">jiti</a> 这个神奇的包</p>\n<p>通过 <code class=\"language-text\">unbuild --stub</code> 生成的文件如下</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> jiti <span class=\"token keyword\">from</span> <span class=\"token string\">\"jiti\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/** @type {import(\"/xx/yy/src/index\")} */</span>\n\n<span class=\"token keyword\">const</span> _module <span class=\"token operator\">=</span> <span class=\"token function\">jiti</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> interopDefault<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> esmResolve<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/xx/yy/src/index.ts\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>可以看到 通过 <code class=\"language-text\">jiti</code> 将源文件进行了绑定，所以其他地方引用这个包时，实际上引用的是源文件。通过这种方式，不再需要启动一个 watch 进程！</p>\n<h2>推荐</h2>\n<p>按照 star 数量来说的话，数量越高，说明越活跃。tsdx  是最高的，功能也很完备，但是 <a href=\"https://github.com/jaredpalmer/tsdx/issues/1058\">tsdx作者不维护tsdx</a> 。tsup 功能也很强大，unbuild 的 bundless build 很特别， stub 模式可以大大提升开发效率。ncc 将所有依赖都打包进最终产物，使得一些需要固定依赖版本的场景非常有用（比如<a href=\"https://github.com/umijs/umi/blob/284b25ad9cde67f2d90b74e1f5df252675bea9bd/scripts/bundleDeps.ts\">umi 就使用ncc预编译所有的依赖</a>)</p>","frontmatter":{"title":"基于rollup/webpack的上层打包工具","date":"August 14, 2022","description":"还在用rollup/webpack打包？快来试试这些好用的新工具吧"}},"previous":{"fields":{"slug":"/reactive-params-in-composition-api/"},"frontmatter":{"title":"如何处理composition api的动态参数"}},"next":null},"pageContext":{"id":"1b59455d-ccf2-55e6-91de-49a481803951","previousPostId":"36b4f61a-35bc-5afc-8470-787e7e7dc1b9","nextPostId":null}},"staticQueryHashes":["2841359383","965855181"]}